#!/bin/bash

if [[ $USEMEM ]]; then
	:
elif [[ $runtime ]]; then
	USEMEM="./usemem --runtime $runtime"
else
	USEMEM=./usemem
fi

SHM_FILE=/dev/shm/sparse-${0/.*case-/}

SPARSE_ROOT=/tmp/vm-scalability
SPARSE_FILE=$SPARSE_ROOT/sparse-${0/.*case-/}
# SPARSE_FSTYPE=$(/usr/bin/stat -fc %T $SPARSE_ROOT)
# [[ $SPARSE_FSTYPE = tmpfs ]] && echo "$SPARSE_ROOT is tmpfs, sparse files won't eat memory." && exit 1
# [[ $SPARSE_FSTYPE = nfs   ]] && echo "$SPARSE_ROOT is nfs, sparse file reads will be slow." && exit 1

PIDFILE=$SPARSE_ROOT/${0/.*case-/}.pid


# sparse files won't work as expected on tmpfs/nfs
create_sparse_root () {
	truncate -s $((256<<20)) $SPARSE_ROOT.img
	# mkfs.btrfs $SPARSE_ROOT.img > /dev/null
	mkfs.ext4 -q -F $SPARSE_ROOT.img > /dev/null
	# mkfs.xfs $SPARSE_ROOT.img > /dev/null
	[[ -d $SPARSE_ROOT ]] || mkdir $SPARSE_ROOT

	# check if already mounted
	if grep -qs "$SPARSE_ROOT" /proc/mounts;then
		echo "$SPARSE_ROOT already mounted"
	else
		mount -o loop $SPARSE_ROOT.img $SPARSE_ROOT
	fi
}

remove_sparse_root () {
	umount $SPARSE_ROOT
	# rmdir $SPARSE_ROOT
	rm $SPARSE_ROOT.img
}

create_sparse_file () {
	name=$1
	size=$2
	# echo "$name is of size $size"
	truncate $name -s $size
	# dd if=/dev/zero of=$name bs=1k count=1 seek=$((size >> 10)) 2>/dev/null
	# ls $SPARSE_ROOT
	# ls /tmp/vm-scalability/*
}


pagesize=$(getconf PAGESIZE)

nr_cpu=$(grep -c processor /proc/cpuinfo)
nr_node=$(echo /sys/devices/system/node/node* | wc -w)

while read key val; do
	[[ $key && $val =~ [0-9]+ ]] || {
		echo "invalid vmstat line: $key $val"
		break
	}
	eval $key=$val
done < /proc/vmstat

reclaimable=$((nr_free_pages + nr_file_pages))
reclaimable=$((reclaimable * pagesize))

while read key val unit; do
	key=${key%%:}
	key=${key%%)}
	key=${key/\(/_}
	eval $key=$val
done < /proc/meminfo

mem=$((MemTotal << 10))
hugepagesize=$((Hugepagesize << 10))

if [[ $ROTATE_BYTES ]]; then
	:
elif [[ $runtime ]]; then
	ROTATE_BYTES=$((1<<48))
else
	ROTATE_BYTES=$mem
fi
